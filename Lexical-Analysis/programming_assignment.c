#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

/**
Given the grammar for a hypothetical imperative programming language,
write a program that analyzes the syntax of input programs for the language

Your program should read an input test program from a file
and then determine whether or not it contains any syntax errors

The program does not have to show where the syntax error occurred
or what kind of error it was

You can use any programming language you prefer to write the program

In your program:

    Implement a lexical analyzer as a subprogram of your program
    Each time the lexical analyzer is called, it should return the next lexeme and its token code
    Implement a parser based on the following EBNF rules
    Create a subprogram for each non-terminal symbol which should parse
    only sentences that can be generated by the non-terminal

EBNF:

<program>               -> program begin <statement_list> end

<statement_list>        -> <statement> {;<statement>}

<statement>             -> <assignment_statement> | <if_statement> | <loop_statement>

<assignment_statement>  -> <variable> = <expression>

<variable>              -> identifier
- An identifier is a string that begins with a letter followed by 0 or more letters and/or digits

<expression>            -> <term> { (+|-) <term>}

<term>                  -> <factor> {(* | /) <factor> }

<factor>                -> identifier | int_constant | (<expr>)

<if_statement>          -> if (<logic_expression>) then <statement>

<logic_expression>      -> <variable> (< | >) <variable>
- Assume that logic expressions have only less than or greater than operators

<loop_statement>        -> loop (<logic_expression>) <statement> */

FILE *filePointer;

void lex(char *);
void program(char *);
void statementList(char *statements);
void parseStatement(char *);
void assignmentStatement(char *);
void ifStatement(char *);
void loopStatement(char *);
void variable(char *);   // see <assignment_statement>
void expression(char *); // see <assignment_statement>

typedef struct
{
  char *part1;
  char *part2;
} SplitResult;

SplitResult split(const char *originalString, const char *splitChars);
char *trim(const char *original);

int main()
{
  FILE *filePointer;
  char *fileContent = NULL;
  long fileLength;

  if ((filePointer = fopen("input1", "r")) == NULL)
  {
    printf("\x1b[1;31mError cannot open file with code to analyze!\n\x1b[0m");
    return 1;
  }

  // Get the length of the file
  fseek(filePointer, 0, SEEK_END);
  fileLength = ftell(filePointer);
  fseek(filePointer, 0, SEEK_SET);

  // Allocate memory for the file content
  fileContent = (char *)malloc(fileLength + 1);
  if (fileContent == NULL)
  {
    fclose(filePointer);
    printf("\x1b[1;31mMemory allocation error.\n\x1b[0m");
    return 1;
  }

  // Read the file into the string
  fread(fileContent, 1, fileLength, filePointer);
  fileContent[fileLength] = '\0'; // Null-terminate the string

  fclose(filePointer);

  // Now you can process 'fileContent' as a single string for lexical analysis.
  lex(fileContent);

  free(fileContent); // Don't forget to free the allocated memory when done.

  printf("\n\n\x1b[1;31;7m End of Parsing \x1b[0m\n\n");

  return 0;
}

void lex(char *programString)
{

  // get the programs statement list
  program(programString);

  char *delimiters = " \t\n+-*/=()<>";
  // printf("File content:\n%s\n", programString);

  char *token = strtok(programString, delimiters);
  while (token != NULL)
  {
    printf("Token:\t%s\n", token);
    token = strtok(NULL, delimiters);
  }
}

/** <program> -> program begin <statement_list> end
Handle overall program of this language */
void program(char *program)
{
  char *delimiters = " \t\n\r\f";
  char *token = strtok(program, delimiters);

  // check for keywords `program` `begin` at the beginning
  if (strcmp(token, "program") == 0)
  {
    token = strtok(NULL, delimiters);
    if (strcmp(token, "begin") == 0)
    {
      statementList(token);
    }
    else
    {
      puts("\n\n\x1b[1;31;7m program \x1b[7;24m keyword missing \x1b[0m\n\n");
      return;
    }
  }
  else
  {
    puts("\n\n\x1b[1;31;7m begin \x1b[24;31;39m keyword missing \x1b[0m\n\n");
    return;
  }
}

/** <statement_list> -> <statement> {;<statement>}
Splits statements_list into statements and parses each statement */
void statementList(char *statements)
{
  char *semicolon = ";";
  char *statement = strtok(NULL, semicolon);
  // statement = strtok(NULL, semicolon);

  while (statement != NULL)
  {
    // parseStatement(statement);
    // printf("statement:\t%s\n", statement);
    char *statementCopy = strdup(statement); // Make a copy of the statement
    parseStatement(statementCopy);           // Parse the copy
    free(statementCopy);                     // Free the copy when you're done with it
    statement = strtok(NULL, semicolon);
  }
}

/** <statement> -> <assignment_statement> | <if_statement> | <loop_statement>
Handles the various kinds of statements */
void parseStatement(char *statement) // can't use statement as the function name
{
  // printf("statement:\t%s\n", statement);
  // determine which of the three kinds statements it is
  if (strstr(statement, "if") != NULL)
  {
    ifStatement(statement);
    return;
  }
  else if (strstr(statement, "loop") != NULL)
  {
    loopStatement(statement);
    return;
  }
  else if (strchr(statement, '='))
  {
    assignmentStatement(statement);
    return;
  }
  else
    printf("\n\n\x1b[1;31;7m <statement> \x1b[24;31;39m Type of statement can't be determined. Maybe the syntax is incorrect \x1b[0m\n%s\n", statement);
}

// The various kinds of statements
/** <assignment_statement> -> <variable> = <expression>  */
void assignmentStatement(char *statement) // no using strtok
{
  printf("\x1b[33m<assignment_statement>:\x1b[1;34m%s\n\x1b[0m", trim(statement));
  SplitResult splitAssignment = split(statement, "=");
  variable(splitAssignment.part1); // check if identifier in variable is correct
  printf("\x1b[33m\t<expression>:\x1b[1;36m%s\x1b[0m\n", splitAssignment.part2);
}
/** <if_statement> -> if (<logic_expression>) then <statement>  */
void ifStatement(char *statement)
{
  printf("\x1b[33m<if_statement>:\n\x1b[1;35m%s\n\x1b[0m", trim(statement));
}
/** <loop_statement> -> loop (<logic_expression>) <statement> */
void loopStatement(char *statement)
{
  printf("\x1b[33m<loop_statement>:\n\x1b[1;36m%s\n\x1b[0m", trim(statement));
}

/** <variable> -> identifier
IDENTIFIER: string; begins with a letter followed by 0 or more letters and/or digits */
void variable(char *variable)
{
  printf("\x1b[33m\t<variable>:\x1b[1;35m%s\x1b[0m\n", variable);
  char firstChar = variable[0];
  if (!isalpha(firstChar))
  { // first character check
    printf("\x1b[1;31;7m <variable>  \x1b[24;31;39m Not syntactically correct! First character in identifier is not a letter\x1b[1;31;7m\n Identifier: \x1b[24;31;39m %s \x1b[1;31;7m Character: \x1b[24;31;39m %c \x1b[0m\n", variable, firstChar);
    return;
  }
  for (int i = 0; i < strlen(variable); i++)
  {
    char character = variable[i];
    if (!isalnum(character)) // error on character: 1 in variable string "sum1"
    {
      printf("\x1b[1;31;7m <variable>  \x1b[24;31;39m Not syntactically correct! Character in identifier is not a letter or digit\x1b[1;31;7m\n Identifier: \x1b[24;31;39m %s \x1b[1;31;7m Character: \x1b[24;31;39m %c \x1b[0m\n", variable, character);
      return;
    }
  }
}

/** <expression> -> <term> { (+|-) <term>} */
void expression(char *expression)
{
  printf("\n\x1b[21;32mExpression:\t%s\t\x1b[0m", trim(expression));
}

// <term>                  -> <factor> {(* | /) <factor> }

// <factor>                -> identifier | int_constant | (<expr>)

// <logic_expression>      -> <variable> (< | >) <variable>
// - Assume that logic expressions have only less than or greater than operators

SplitResult split(const char *originalString, const char *splitChars)
{
  char *str = trim(originalString);
  char *str2 = NULL;

  // Find the first occurrence of any character in splitChars
  char *splitPos = strpbrk(str, splitChars);

  if (splitPos)
  {
    // Split the string at the found position
    *splitPos = '\0';
    str2 = trim(splitPos + 1);
  }
  else
  {
    // No split character found, set str2 to NULL
    str2 = NULL;
  }

  SplitResult result;
  result.part1 = strdup(trim(str));
  result.part2 = str2 ? strdup(trim(str2)) : NULL;

  free(str); // Free dynamically allocated memory
  return result;
}

/* Trims whitespace characters from beginning and end then returns string */
char *trim(const char *original)
{
  int start = 0;
  int end = strlen(original) - 1;

  // Find the first non-whitespace character
  while (isspace(original[start]))
    start++;

  // Find the last non-whitespace character
  while (end > start && isspace(original[end]))
    end--;

  // Calculate the length of the trimmed string
  int length = end - start + 1;

  // Allocate memory for the trimmed string and copy the content
  char *trimmedStr = (char *)malloc(length + 1); // +1 for null terminator
  strncpy(trimmedStr, original + start, length);
  trimmedStr[length] = '\0'; // Null-terminate the string

  return trimmedStr;
}
